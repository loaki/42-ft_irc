/*
    **  int socket(int domain, int type, int protocol);
    --socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket 系统建立一通信端口
    socket分成两种：
        一种专门用来监听新链接（或新活动），这种socket叫做master socket，一般只存在于服务器
        一种专门用来收发数据，这种socket叫做connected socket，客户端和服务器都存在
    domain：协议族（address family)AF_INET、AF_INET6、AF_LOCAL 协议族决定了socket的地址类型,对于TCP/IP协议族，该参数置AF_INET。
    type：指定socket类型 流套接字类型SOCK_STREAM、数据报套接字类型SOCK_DGRAM
        SOCK_STREAM 提供双向连续且可信赖的数据流, 即TCP. 所有数据传送前必须使用connect()来建立连线状态.
    protocol:协议类型，通常是IPPROTO_TCP或IPPROTO_UDP
    socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址
        给它赋值一个地址，调用bind()函数, 否则就当调用connect()、listen()时系统会自动随机分配一个端口
    成功则返回socket处理代码, 失败返回-1

    **  int bind(int socket,sockaddr * address,uint addrlen);
    ---将一个地址和一个端口号 绑定到一个socket上,给它赋值一个地址端口号
    socket:之前创建的socket
    sockaddr:一个用来存放Ip地址和端口号的结构体
    addrlen:上述结构体的长度
    返回值：为-1表示失败，若端口被占用，会从新绑定一个随机端口（仍返回失败）,地址绑定为0表示绑定本机所有IP

    **  int recv(int socket,char * buf,uint buflen,int flag);【阻塞】
    ---UDP时：接收任何一个发送到该socket的消息（无法获取发送方地址） TCP时：接收一个已连接的socket (connected socket)发送的信息
    socket:UDP时，为之前创建的socket，TCP时，为connected socket 请确保socket是已连接的，因为只有已连接的socket会阻塞此函数
    buf:接收的缓冲区
    buflen:缓冲区的长度
    flag:一般为0
    返回值：>0表示收到的字节数，=0表示连接被关闭，-1表示出错
    函数实际上是从缓冲区取指定长度的数据，如果缓冲区没有数据，则会阻塞；如果没有取完，则下次使用此函数的时候不会阻塞
    当一次无法获得对方发送的全部数据，在数据不完整的时候，程序可能无法向下执行，可以考虑将数据放在缓冲区中，等数据全部接收完成的时候再使用

    **  int getsockname(int socket,sockaddr * address,int * addrlen);
    ---获取指定socket上绑定的IP、端口信息（不能获取connected socket上的地址信息）
    address:socket上绑定的地址(输出参数)
    addrlen:socket上绑定的地址结构体的长度（输入输出参数）

    ** int listen(int socket,int maxconn);【仅TCP】【服务器】
    将一个socket设置为监听状态,专门用来监听的socket叫做master socket
    maxconn:最大接收连接数
    返回值：失败返回-1，成功返回0

    ** int accept(int socket,sockaddr * fromaddr,int * addrlen);【阻塞】【仅TCP】【服务器】
    --接收一个客户机的连接，返回一个socket，来自客户机的socket叫connected socket
    socket:用来监听的socket（master socket）
    fromaddr:客户机的地址信息
    addrlen:地址结构体的长度（输入输出参数）
    返回值：返回一个新的socket，这个socket专门用来与此客户机通讯（connected socket）

    **int connect(int socket, sockaddr * addr,int addrlen);【仅TCP】【客户端】
    使用当前socket连接一个地址（与服务器建立正式连接），此函数会触发服务器端的accept、select函数
    注意：服务端接收的socket值和客户端socket值不一样
    addr:一般是服务器地址

    **int send(int socket,char * buf,char buflen,int flag);【仅TCP】
    ---向一个已连接的socket发送信息，这个socket应该是connected socket（非master socket）

    **int closesocket(int socket);
    关闭一个已存在的socket【正常关闭】
    失败返回-1，成功返回0


    
*/

seletct:实现非阻塞编程 轮循函数，循环询问文件节点，可设置超时时间，超时时间到了就跳过代码继续往下执行。
select通过每个设备文件对应的poll函数提供的信息判断当前是否有资源可用(如可读或写)，如果有的话则返回可用资源的文件描述符个数，没有的话则睡眠，等待有资源变为可用时再被唤醒继续执行。

int select(int maxfdp, fd_set* readset, fd_set* writeset, fd_set *errorfds, struct timeval* timeout);
maxfdp      需要检查的文件描述字个数 即所有文件描述符的最大值加1
readset     用来检查可读性的一组文件描述字。 如果这个集合中有一个文件可读，select就会返回一个大于0的值，表示有文件可读
writeset     用来检查可写性的一组文件描述字。 如果这个集合中有一个文件可写，select就会返回一个大于0的值，表示有文件可写
errorfds   用来检查是否有异常条件出现的文件描述字。(注：错误不包括在异常条件之内)
timeout      是select的超时时间
            第一：若将NULL以形参传入，即不传入时间结构，就是将select置于阻塞状态 一定等到监视文件描述符集合中某个文件描述符发生变化为止；
            第二：若将时间值设为0秒0毫秒，就变成一个纯粹的非阻塞函数，不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值；
             第三：timeout的值大于0，这就是等待的超时时间，即select在timeout时间内阻塞，超时时间之内有事件到来就返回了，否则在超时后不管怎样一定返回，返回值同上述

返回fd的总数， 0：等待超时，没有可读写或错误的文件
            正值：select()调用返回处于就绪状态并且已经包含在fd_set结构中的描述字总数；
            负值：select错误 返回SOCKET_ERROR错误，应用程序可通过WSAGetLastError()获取相应错误代码

-fd_set可以理解为一个集合，这个集合中存放的是文件描述符(file descriptor) 一个socket就是一个文件，socket句柄就是一个文件描述符
-struct timeval是一个大家常用的结构，用来代表时间值，有两个成员，一个是秒数，另一个毫秒数。

FD_SET(int fd, fd_set *fdset);       //将fd加入set集合
FD_CLR(int fd, fd_set *fdset);       //将fd从set集合中清除
FD_ISSET(int fd, fd_set *fdset);     //检测fd是否在set集合中，不在则返回0
FD_ZERO(fd_set *fdset);              //将set清零使集合中不含任何fd


如何从零写一个http server?
1.建立一个TCP Socket服务器。
监听某个指定端口（默认HTTP服务在80），接收访问请求并建立连接，接收发来的流，并且提供回复流的能力
2.编写一个解析HTTP Request的解析器。
Request分表头和正文，包括访问地址、UA、Cookie等各类参数以及提交的表单等内容。详细格式看看HTTP协议文档就好。
3.实现URL路由。
根据地址来指定内容的工作就是路由，把不同的路径交给不同的程序（函数、脚本…）处理。
4.产生Respons
区分表头和正文，多几个关机字表示当前相应状态、响应内容类型之类的东西。正文里就是你需要的回应，可能是个json，可能是个静态文件，
也可能是别的什么东西。从路由处得到响应的内容，然后按照HTTP Response的要求包起来。最后经过之前的Socket服务返回给用户。

----------------http 协议------------------------
http 协议格式:  type source http
example:http://www.hootina.org/index_2013.php?param1=value1&param2=value2&param3=value3
<header>

GET /index_2013.php?param1=value1&param2=value2&param3=value3 (url:delete domain name) HTTP/1.1\r\n
Host: www.hootina.org\r\n
Connection: keep-alive\r\n
User-Agent:
Accept: 
Accept-Language: zh-CN, en;
\r\n

example:我们在 12306 网站 https://kyfw.12306.cn/otn/login/init 浏览器以POST方式组装了http协议包发送了我们的用户名、密码和其他一些信息
<header>
POST /otn/login/init HTTP/1.1
Host:kyfw.12306.cn\r\n
Connection:keep-alive\r\n
Content-Length: 55\r\n
Accept:*/*
Origin: https://kyfw.12306.cn\r\n
Referer: https://kyfw.12306.cn/otn/login/init\r\n
Accept-Language:
Cookie: \r\n
\r\n
<body>
username=xuwang%40qq.com&password=mypassword&appid=otn

GET         请求指定的页面信息，并返回实体主体。
POST        向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
DELETE      请求服务器删除指定的页面。
GET请求会把请求的参数拼接在URL后面，以?分隔，多个参数之间用&连接；如果是英文或数字，原样发送，如果是空格或中文，则用Base64编码

(解析数据)http 服务器实现:serveur
string inbuf;
-先把所有数据都取出来 //因为一个http包头的数据至少\r\n\r\n，所以大于4个字符 //小于等于4个字符，说明数据未收完，退出，等待网络底层接着收取
-检查是否以\r\n\r\n结束，如果不是说明包头不完整，退出
-以"\r\n"分割每一行 split
-根据" "空格分成三段,GET中至少有三个字符串：GET+url+HTTP 第二段就是我们的网址和参数
    %20是空格的 URL 转码形式
-问号"?"将这个分成两段:分割成前后两端，第一段是网址，第二段是参数 

-BOOL process(): url.empty(), (url == "/register.do"), (url == "/login.do") (url == "/getfriendlist.do")...
-URL匹配网址，如果是注册请求，会走注册处理逻辑：
-将数据组装成 http 协议发给客户端 将数据组装成 http 协议发给客户端:
    HTTP/1.1 200 OK\r\n
    {%22code%22:%200,%20%22msg%22:%20%22ok%22}
判断收到的数据长度,假定，我们能处理的最大 URL 长度是 2048,累积不含 \r\n\r\n 我们认为连接非法，将连接断开


1、\n 软回车：
在Windows 中表示换行且回到下一行的最开始位置。相当于Mac OS 里的 \r 的效果。
在Linux、unix 中只表示换行，但不会回到下一行的开始位置。

2、\r 软空格：
在Linux、unix 中表示返回到当行的最开始位置。
在Mac OS 中表示换行且返回到下一行的最开始位置，相当于Windows 里的 \n 的效果。
 


TCP通讯流程（服务器）：
WSAStartup()
socket()
bind()
listen()
accept()
send()/recv() 网络I/O操作
1、创建用于监听的套接字（socket）
2、将套接字绑定到本地地址和端口上（bind）
3、将套接字设为监听模式（listen） listen()、connect()函数
4、等待客户请求（accept），此处要不断的调用accept
5、通信（send/receive），完成后返回4


htonl()--"Host to Network Long"
ntohl()--"Network to Host Long"
htons()--"Host to Network Short"
ntohs()--"Network to Host Short"  
  
套接字Socket=（IP地址：端口号 十进制的lP地址后面写上端口号 那么得到套接字就是(210.37.145.1:23)

